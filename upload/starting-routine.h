/* 
 * File:   starting-routine.h
 * Author: Henry
 *
 * Created on July 24, 2014, 12:09 PM
 */

#ifndef STARTING_ROUTINE_H
#define	STARTING_ROUTINE_H

#ifdef	__cplusplus
extern "C" {
#endif
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <kovan/kovan.h>
#include <sys/time.h>
#include <string.h>
#include <assert.h>

#include "song.h"
#include "Constants.h"
#include "claw-utils.h"
#include "drive-utils.h"


#define DRIVE_SPEED_FORWARD -7
#define DRIVE_SPEED_BACKWARD 11

#define SPIN_SPEED 3
    void jerk();
    long getMS(struct timeval time) {
        return time.tv_sec * 1000 + time.tv_usec / 1000;
    }

    void runAutogeneratedCode1() {
        create_drive_straight(0);

        create_spin_CW(150);

        msleep(630);

        create_drive_straight(0);

        create_drive_straight(-500);

        msleep(1320);

        create_drive_straight(0);

        create_spin_CCW(150);

        msleep(1090);

        create_drive_straight(0);

        create_drive_straight(500);

        msleep(1240);

        create_drive_straight(0);

        create_spin_CW(150);

        msleep(280);

        create_drive_straight(0);

        /*create_spin_CW(150);

        msleep(230);

        create_drive_straight(0);*/

        create_drive_straight(500); //back into the slot
        //set_servo_position(CUBE_KNOCK_PORT, CUBE_KNOCK_UP);
        msleep(500); //990
        set_servo_position(CUBE_KNOCK_PORT, CUBE_KNOCK_UP2);
        create_drive_straight(0);

        create_spin_CW(150);

        while (analog(RAMP_TOP_HAT) > 930) {
        }
        //set_servo_position(CUBE_KNOCK_PORT, CUBE_KNOCK_UP);
        create_spin_CW(-100);
        msleep(160); //HOW much to back off from the wall  250 is perfect  was 100
         
        create_drive_straight(0);
        //exit(0);
        //create_spin_CW(-100);

        //msleep(250);
    }

    void driveLeft() {
        create_drive(-500, 2000);

    }

    void driveRight() {
        create_drive(-500, -2000);
    }

    void cDriveStraight() {
        create_drive_straight(-500);
    }

    void driveAdaptive(long timeoutMS) {
        struct timeval startTime;
        gettimeofday(&startTime, NULL);
        struct timeval currentTime;
        gettimeofday(&currentTime, NULL);

        int lastDistance = analog(RAMP_TOP_HAT);
        int currentDistance;

        cDriveStraight();
        while (getMS(currentTime) - getMS(startTime) < timeoutMS) {
            currentDistance = analog(RAMP_TOP_HAT);

            if (currentDistance < lastDistance) {
                driveLeft();
            } else if (currentDistance == lastDistance) {
                cDriveStraight();
            } else {
                driveRight();
            }
            msleep(100);
            gettimeofday(&currentTime, NULL);
        }
        create_drive_straight(0);
    }

    void runAutogeneratedCode2(bool slow) {
        create_drive_straight(0);
        //driveAdaptive(1170);
        
        
        create_drive_straight(-500);
        msleep(1170);
        create_drive_straight(0);
        
        //create_drive(-500, -2000);
        
        set_servo_position(CUBE_KNOCK_PORT, CUBE_KNOCK_DOWN);
        create_drive_straight(-400);

        msleep(300);
        //create_drive(-400, -2000);
        create_drive_straight(-500);
        msleep(250);
        create_drive_straight(-400);
        create_drive(-400, 2000);
        msleep(151); //time before putting up cube knock //Was 1341
        set_servo_position(CUBE_KNOCK_PORT, CUBE_KNOCK_UP);

        //driveAdaptive(1501);
        driveLeft();
        msleep(300);
        cDriveStraight();
        
        
        msleep(701);
        create_drive_straight(0);
        
        create_spin_CCW(150);
        msleep(700);
        
        create_drive_straight(0);
        cDriveStraight();
        msleep(600);
        
        create_drive_straight(0);
        jerk();
    }

    void jerk() {
        for (int i = 0; i < 2; i++) {
            create_drive_straight(-500);
            msleep(300);
            create_drive_straight(500);
            msleep(500);
        }
        create_drive_straight(0);
        for (int i = 0; i < 5; i++) {
            create_spin_CCW(500);
            msleep(100);
            create_spin_CW(500);
            msleep(100);
        }


    }

    void preformStartingRoutine() {
        char s[20];
        raise_claw_to(CLAW_UP_POSITION);
        //was down
        set_servo_position(CUBE_KNOCK_PORT, CUBE_KNOCK_DOWN);
        //set_servo_position(CUBE_KNOCK_PORT, CUBE_KNOCK_UP2);
        enable_servo(CUBE_KNOCK_PORT);

        playSong();
        printf("GO!!!!!\n");
        /*
                //this is the code to start half way through
                set_servo_position(CUBE_KNOCK_PORT, CUBE_KNOCK_UP2);
                runAutogeneratedCode2(false);
                create_drive_straight(300);
                msleep(1100);
                create_drive_straight(0);
                jerk();
                return;
         */
        runAutogeneratedCode1();
        create_drive_straight(0);

        set_servo_position(CUBE_KNOCK_PORT, CUBE_KNOCK_UP2);
        //enable_servo(CUBE_KNOCK_PORT);
        printf("waiting for input...\n");
        scanf("%s", s);
        if (strcmp(s, "exit") == 0) {
            return;
        } else if (strcmp(s, "slow") == 0) {
            runAutogeneratedCode2(true);
        } else {
            runAutogeneratedCode2(false);
        }

        create_drive_straight(300);
        msleep(1100);
        create_drive_straight(0);
        jerk();
        //char s[20];
        //scanf("%s\n",s);
        set_servo_position(CUBE_KNOCK_PORT, CUBE_KNOCK_DOWN);

    }


#ifdef	__cplusplus
}
#endif

#endif	/* STARTING_ROUTINE_H */

